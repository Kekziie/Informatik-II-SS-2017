\documentclass[paper=a4, fontsize=11pt]{scrartcl} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Kim Thuong Ngo}


\usepackage[T1]{fontenc} 
\usepackage{fourier} 

\usepackage{lipsum} 

\usepackage{listings}
\usepackage{graphicx}
\usepackage{tabularx}

\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape} 

\usepackage{fancyhdr} 
\pagestyle{fancyplain} 
\fancyhead{}
\fancyfoot[L]{} 
\fancyfoot[C]{} 
\fancyfoot[R]{\thepage} 
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt}
\setlength{\headheight}{13.6pt}

\numberwithin{equation}{section} 
\numberwithin{figure}{section} 
\numberwithin{table}{section}

\setlength\parindent{0pt} 

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 

\title{	
\normalfont \normalsize 
\textsc{Informatik II} \\ [25pt] 
\horrule{0.5pt} \\[0.4cm] 
\huge Papieraufgaben \\ 
\horrule{2pt} \\[0.5cm] 
}

\author{Kim Thuong Ngo} 

\date{\normalsize\today} 

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle 

\newpage

\tableofcontents

\newpage

%----------------------------------------------------------------------------------------

\section{Blatt 01}

\paragraph{Aufgabe 1.2} Taschenrechner Papier \\

a) Wieso darf h bei der Berechnung der numerischen Ableitung in der Taschenrechneraufgabe nicht beliebig klein gewählt werden? Was passiert, wenn Sie h=0 setzen? \\

h darf bei der Berechnung nicht beliebig klein gewählt werden, da der Datentyp "double" eine Genauigkeit von 15 Signifikaten besitzt, d.h. es funktioniert nicht für sehr klein gewählte h. \\
Nach der Definition darf h nicht gleich Null gesetzt werden, da man nicht durch 0 teilen darf. \\

b) Was passiert bei der ggT Berechnung, wenn Sie eine negative Zahl eingeben und Sie diesen Fall nicht abfangen -  also wenn Sie den iterativen bzw. rekursiven Algorithmus ganz normal ausführen? \\

Es entsteht eine Endlosschleife, d.h. die Funktion würde nicht terminieren und endlos weiterlaufen. \\

c) Führen Sie den ggT Algorithmus wie oben beschrieben auf ggT(42,63) und auf ggT(15,9) aus - geben Sie alle Unteraufrufe (bzw. rekursive Aufrufe) von ggT an! \\


\textbf{ggT(42,63)}\\
$\longrightarrow ggT(42,21)$\\
$\longrightarrow ggT(21,21)$\\
$\longrightarrow$ Lösung ist 21\\

\textbf{ggT(15,9)} \\
$\longrightarrow ggT(6,9)$ \\
$\longrightarrow ggT(6,3)$ \\
$\longrightarrow ggT(3,3)$ \\
$\longrightarrow$ Lösung ist 3\\

%--------------------------------------------------

\paragraph{Aufgabe 1.3} Induktionsbeweis \\
Beweisen Sie mittels vollständiger Induktion, dass $3$ stets ein Teiler von $n^{3}-n$ ist - für alle $n \in \mathbb{N}$ \\

\textbf{Induktionsanfang: $n=1$}\\
$n^{3}-n = 1^{3}-1 = 1-1 = 0$ \\
$\longrightarrow$ $0$ ist durch $3$ teilbar \\

\textbf{Induktionsschritt: $n \longrightarrow n+1$}\\
Induktionsvoraussetzung: $n^{3}-n$ ist eine durch $3$ teilbare Zahl\\
Induktionsbehauptung: $(n+1)^{3}-(n+1)$ ist durch $3$ teilbar\\
Beweis:\\
$(n+1)^{3}-(n+1)$\\
$= n^{3}+3n^{2}+3n+1-n-1$\\
$= n^{3}+3n^{2}+2n$\\
$= n^{3}-n+3n^{2}+3n$\\
$= (n^{3}-n)+3(n^{2}+n)$\\
Nach IV ist $n^{3}-n$ durch $3$ teilbar. \\
Der zweite Term $3(n^{2}+n)$ ist ein ganzzahliges Vielfaches von $3$, $3$ ist durch $3$ teilbar, und somit ist die Summer durch 3 teilbar.\\ 
\begin{flushright}
\hfill $\square$
\end{flushright}

%--------------------------------------------------

%----------------------------------------------------------------------------------------

\newpage

\section{Blatt 02}

\paragraph{Aufgabe 2.2} Numerische Optimierung \\

a) Geben Sie die Stellen der gefundenen Minima (x,y) für die Werte $x_{0}=2,,6,8,10,12$ in einer Tabelle aus - und zwar für beide Funktionen und jeweils für $\vert x_{l}-x_{l+1} \vert < 10^{-7}$ und $ \vert x_{l}-x_{l+1} \vert < 10^{-9}$\\

func=0: $f_{1}(x)=1.84+1.42x-2.4x^{2}+0.91x^{3}+0.124x^{4}+0.0055x^{5}$\\
func=1: $f_{2}(x)=(x-a)^{2}+b$ \\

\begin{tabular}{|c|c|c|}
  \hline
   Werte/Funktion & func=0 mit $10^{-7}$ & func=0 mit $10^{-9}$ \\ 
   \hline
   2 & X=2.652110176077500  & X=2.6521884473720894   \\ 
     & Y=0.287406447732254 & Y=0.2874064437749117 \\
   \hline
   4 & X=2.652268267405512  & X=2.652190027888739   \\ 
     & Y=0.287406447729125 & Y=0.2874064437749115 \\
   \hline
   6 & X=9.35867462035928 & X=9.35869082479512   \\ 
     & Y=-5.53137102121286 & Y=-5.53137102203488  \\
   \hline
   8 & X=9.35867460059416  & X=9.35869082551920 \\ 
     & Y=-5.53137102121087 & Y=-5.53137102203493 \\
   \hline
   10 & X=9.35870737830612  & X=9.35869115359424 \\ 
      & Y=-5.53137102121104 & Y=-5.53137102203510 \\
   \hline
   12 & X=9.35870731749117  & X=9.35869115388596 \\ 
      & Y=-5.53137102121696 & Y=-5.53137102203505 \\
   \hline 
 \end{tabular}
 \\
 
 \begin{tabular}{|c|c|c|}
  \hline
   Werte/Funktion & func=1 mit $10^{-7}$ & func=1 mit $10^{-9}$ \\ 
   \hline
   2 & X=4.99994994521164  & X= 4.99999949916960 \\ 
     & Y=-1.999999997494518 & Y=-1.999999999999749\\
   \hline
   4 & X=4.99994992082009 & X=4.999999499927895 \\ 
     & Y=-1.999999997492076 & Y=-1.99999999999975 \\
   \hline
   6 & X=5.00005007917991  & X=5.00000050007210 \\ 
     & Y=-1.999999997492076 & Y=-1.99999999999975 \\
   \hline
   8 & X=5.00005005478834  & X=5.0000005008304 \\ 
     & Y=-1.999999997494518 & Y=-1.999999999999749 \\
   \hline
   10 & X=5.00005007055525  & X=5.00000050098819 \\ 
      & Y=-1.999999997492939 & Y=-1.999999999999749 \\
   \hline
   12 & X=5.00005007735475  & X=5.00000050005405 \\ 
      & Y=-1.999999997492258 & Y=-1.99999999999975 \\
   \hline 
 \end{tabular} 
 \\

b) Welche weiteren Abbruchbedingungen wären für die Anwendung an beliebigen Funktionen sinnvoll zu testen? Nennen Sie mind. zwei. Begründen Sie! \\

1.) Abbruch der Auswertung durch Überschreitung eines Wertes (definierte Grenze)\\
2.) Monotonie $ \rightarrow $ streng monotone Funktion keine Extremstellen \\

%--------------------------------------------------

\paragraph{Aufgabe 2.3} Schleifen, Reihen und Berechnungen \\

a) Sei $a_{k} = \dfrac{(-1)^{k}}{2k+1}$ das k-te Folgenglied einer Folge $(a_{k})_{k=0,1,2,...}$. Die Folge beginnt demnach mit $1, \dfrac{-1}{3}, \frac{1}{5}, \dfrac{-1}{7}, ...$. Berechnen Sie Werte der Reihe der $4* \Sigma^{n}_{k=0} a_{k}$. Benutzen Sie den Datentyp double. Geben Sie die Werte der Reihe für $n=10^{i}$ mit $i=\lbrace 1,2,3,4,5,7 \rbrace$ aus. Gegen welchen Wert scheint die Reihe zu konvergieren? \\

 \begin{tabular}{|c|c|}
  \hline
    & Werte \\ 
   \hline
   $10^{1}$ & $3.23231580940$\\ 
   \hline
   $10^{2}$ & $3.15149340107$\\ 
   \hline
   $10^{3}$ & $3.1425916543395$\\ 
   \hline
   $10^{4}$ & $3.141692643590$\\ 
   \hline
   $10^{5}$ & $3.1416026534897$\\ 
   \hline
   $10^{6}$ &$ 3.1415936535887$\\ 
   \hline
   $10^{7}$ & $3.1415927535898$\\ 
   \hline 
 \end{tabular}
 \\
 
$\rightarrow$ die Werte konvergieren gegen $\pi$ \\

b) Collatz-Vermutung\\
überprüfen der Vermutung für n=1,2,...$10^{6}$ \\

Anzahl der Folgeglieder von x=[1000;1010] $\rightarrow$ x und 1 eingerechnet\\

\begin{tabular}{|c|c|}
  \hline
    & Anzahl \\ 
   \hline
   1000 & 112\\ 
   \hline
   1001 & 143\\ 
   \hline
   1002 & 112\\ 
   \hline
   1003 & 42\\ 
   \hline
   1004 & 68\\ 
   \hline
   1005 & 68\\ 
   \hline
   1006 & 68\\ 
   \hline
   1007 & 94\\ 
   \hline
   1008 & 112\\ 
   \hline
   1009 & 112\\ 
   \hline
   1010 & 63\\ 
   \hline 
\end{tabular}
\\
 
 \begin{tabular}{|c|c|}
  \hline
   Eingabe 10-19 & Folgeglieder \\ 
   \hline
   10 & 5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1 \\ 
   \hline
   11 & 34$\rightarrow$17$\rightarrow$52$\rightarrow$26$\rightarrow$13$\rightarrow$40$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   12 & 6$\rightarrow$3$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   13 & 40$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   14 & 7$\rightarrow$22$\rightarrow$11$\rightarrow$34$\rightarrow$17$\rightarrow$52$\rightarrow$26$\rightarrow$13$\rightarrow$40$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   15 & 46$\rightarrow$23$\rightarrow$70$\rightarrow$35$\rightarrow$106$\rightarrow$53$\rightarrow$160$\rightarrow$80$\rightarrow$40$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   16 & 8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   17 & 52$\rightarrow$26$\rightarrow$1340$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   18 & 9$\rightarrow$28$\rightarrow$14$\rightarrow$7$\rightarrow$22$\rightarrow$11$\rightarrow$34$\rightarrow$17$\rightarrow$52$\rightarrow$26$\rightarrow$13$\rightarrow$40$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline
   19 & 58$\rightarrow$29$\rightarrow$88$\rightarrow$44$\rightarrow$22$\rightarrow$11$\rightarrow$ 34$\rightarrow$17$\rightarrow$52$\rightarrow$26$\rightarrow$13$\rightarrow$40$\rightarrow$20$\rightarrow$10$\rightarrow$5$\rightarrow$16$\rightarrow$8$\rightarrow$4$\rightarrow$2$\rightarrow$1\\ 
   \hline 
\end{tabular}
\\
 
c) Auswertung eines Polynoms über ein Java-Programm:\\
$ f(x,y)=333.75*y^{6}+x^{2}*(11*x^{2}*y^{2}-y^{6}-121*y^{4}-2)+5.5*y^{8}+\dfrac{x}{(2*y)}$ \\

\begin{tabular}{|c|c|}
  \hline
    & Wert \\ 
   \hline
   Java-Wert - double & $-1,1805916207174113*10^{21}$\\ 
   \hline
   Java-Wert - float & $-6,338253*10^{29}$\\ 
   \hline
   Wolfram Alpha &  -0.82739605994682136814116509547981629199903311578438481991\\ 
   \hline 
\end{tabular} 
\\
 
Auswertung:\\
Der Wert von Wolfram Alpha ist am genauesten, da dieser ein Datentyp verwendet der mehr signifikante Stellen ermöglicht. Im Gegensatz dazu ist double mit seiner 64 Bit Darstellung zwar schlechter als Wolfram Alpha, aber wesentlich genauer als float.
 
%--------------------------------------------------

%----------------------------------------------------------------------------------------

\newpage

\section{Blatt 03}

\paragraph{Aufgabe 3.2} Explizite Typumwandlung \\
Betrachten Sie die folgende Variablenzuweisung unter Java \\

\begin{center}
\textbf{int} i = 5;\\
\textbf{short} s = 3;\\
\textbf{float} f = 5;\\
\textbf{char} a = 'a';\\
\textbf{double} d = 18.8;\\
\textbf{long} l = 34;\\
\textbf{byte} by = 1;\\
\end{center}

a) Welche der folgenden Zuweisungen sind zulässig? Korrigieren Sie die übrigen Anweisungen wenn möglich durch Einfügen einer expliziten Typveränderung \\

  \begin{tabular}{|c|c|c|}
  \hline
            & Zulässigkeit & eventuelle Korrektur \\
  \hline
l = 1;      & $\surd$  & \\
  \hline
i = l + 90; & X & i = (int) l + 90;\\
  \hline
d = f;      & $\surd$  & \\
  \hline
f = s;      & $\surd$  & \\
  \hline
by = d;     & X & by = (byte) d;\\
  \hline
a = i;      & X & a = (char) i;\\
  \hline
i = d;      & X & i = (int) d; \\
  \hline
f = i;      & $\surd$ & \\
  \hline
  \end{tabular}
\\

%--------------------------------------------------

\paragraph{Aufgabe 3.3} Rechnen mit Binärzahlen \\
Geben Sie für die im Zehnersystem dargestellten Zahlen x=63 und y=26 die zugehörigen Repräsentationen im Zweiersystem an. \\

\begin{center}
  \begin{tabular}{|c|c|c|}
  \hline
            & Zahl im Zehnersystem & Zahl im Binärsystem \\
  \hline
x    & $63_{10}$  & $111111_{2}$\\
  \hline
y    & $26_{10}$ & $11010_{2}$\\
  \hline
  \end{tabular}
\end{center} 

Berechnung: \\
  \begin{tabular}{|c|c|}
  \hline
Division & Rest\\
  \hline
63 / 2 = 31 & 1 \\
  \hline
31 / 2 = 15  & 1 \\
  \hline
15 / 2 = 7  & 1 \\
  \hline
7 / 2 = 3  & 1 \\
  \hline
3 / 2 = 1  & 1 \\
  \hline
1 / 2 = 0  & 1 \\
  \hline
  \end{tabular} \\
  
Daraus folgt: $63_{10} \rightarrow 111111_{2}$ \\

  \begin{tabular}{|c|c|}
  \hline
Division & Rest\\
  \hline
26 / 2 = 13 & 0 \\
  \hline
13 / 2 = 6  & 1 \\
  \hline
6 / 2 = 3  & 0 \\
  \hline
3 / 2 = 1  & 1 \\
  \hline
1 / 2 = 0  & 1 \\
  \hline
  \end{tabular} \\
  
  Daraus folgt: $26_{10} \rightarrow 11010_{2}$ \\

a) Addieren Sie die beiden Binärzahlen von Hand \\

Rechnung mit Übertrag in der Tabelle\\

\begin{tabular}{cr}
	&$ 1 1 1 1 1 1$	\\
	+&$  1 1 0 1 0$	\\\hline 
	&$  1 0 1 1 0 0 1$
\end{tabular} \\

  \begin{tabular}{|c|c|}
  \hline
Addition & Übertrag\\
  \hline
1+0=1 & 0 \\
  \hline
1+1=0 & 1 \\
  \hline
1+0+1=0 & 1 \\
  \hline
1+1+1=1 & 1 \\
  \hline
1+1+1=1 & 1 \\
  \hline
1+1=0 & 1 \\
  \hline
  \end{tabular} \\

b) Multiplizieren Sie die beiden Binärzahlen von Hand \\


\begin{tabular}{c}
	$\:\: 1 1 1 1 1 1 *  1 1 0 1 0$ \\\hline
	$111111$\\
	$\:\:\:111111$\\ 
	$\:\:\:\:\:\:\: 000000$\\
	$\:\:\:\:\:\:\:\:\:\: 111111$\\
	$\:\:\:\:\:\:\:\:\:\:\:\:\: 000000$\\\hline
	$\:\: 11001100110$
\end{tabular}
\\

Rechnung mit Übertrag in der Tabelle\\

\begin{tabular}{cr}
	&$ 1111 1100 00$	\\
	&$ 1111 1100 0$	\\
   +&$ 1111 110$	\\\hline 
	&$ 11001100110$
\end{tabular}
\\

  \begin{tabular}{|c|c|}
  \hline
Addition & Übertrag\\
  \hline
0+0+0=0 & 0 \\
  \hline
0+0+1=1 & 0 \\
  \hline
0+0+1=1 & 0 \\
  \hline
0+1+1=0 & 1 \\
  \hline
1+1+1+1=0 & 1+1 \\
  \hline
1+1+1+1+1=1 & 1+1 \\
  \hline
1+1+1+1+1=1 & 1+1 \\
  \hline
1+1+1+1=0 & 1+1\\
  \hline
1+1+1+1=0 & 1+1 \\
  \hline
1+1+1+1=0 & 1+1 \\
  \hline
  \end{tabular} \\

Überprüfung der Werte \\
Umwandlung der Zahlen von Binärsystem in Dezimalsystem und Vergleich mit Ergebnissen der Werte im Dezimalsystem von der Addition und Multiplikation \\


a) $1011001_{2}$\\
$2^{0}+2^{3}+2^{4}+2^{6}$\\
$=1+8+16+64$\\
$=89_{10}$\\

$ x+y= 26_{10}*63_{10} = 89_{10} \:\:\:\:\: \surd$ \\


b) $11001100110_{2}$\\
$2^{1}+2^{2}+2^{5}+2^{6}+2^{9}+2^{10}$\\
$=2+4+32+64+512+1024$\\
$=1638_{10}$\\

$ x*y= 26_{10}*63_{10} =1638_{10} \:\:\:\:\: \surd$ \\

%--------------------------------------------------

\paragraph{Aufgabe 3.4} Blöcke, Anweisungen und Schleifen 

a) Kompilieren Sie folgende Programme und erläutern Sie die dabei auftretenden Fehler bzw. unerwartetes Verhalten. \\

\textbf{i) Block 1:} \\

\begin{lstlisting}
class block1 {
  public static void main(String[] args) {
  int i; {
    i = 3;
    int j = 4
    }
  i = j;
  System.out.println(i);
  }
}  
\end{lstlisting}

\textbf{Fehlermeldung}: j cannot be resolved to a variable\\
Erklärung:\\
Es gab ein Fehler bei der Übersetzung, weil die Deklaration der Variable j sich in einem inneren Block befindet, d.h. die Variable j ist nur innerhalb dieses Blockes gültig. Da sich die Wertzuweisung i=j außerhalb dieses Blockes befindet, kann dieser nicht auf die Variablendeklaration zugreifen und es entsteht die Fehlermeldung. \\

\textbf{i) Block 2:} \\
\begin{lstlisting}
class block2 {
  public static void main(String[] args) {
  int i = 0; {
    i = 3;
    }
  System.out.println(i);
  }
}  
\end{lstlisting}

Das Programm terminiert zum Wert 3.\\
Erklärung:\\
Die Deklaration der Variable i nimmt den Wert 0 an. Da aber, in einem inneren Block, eine neue Wertzuweisung für die Variable i eingeführt wird, ändert sich der  Wert von 0 auf 3. Deshalb ist das Ergebnis des Programmes 3. \\

b) Welchen Wert hat die Variable x nach Ausführung der jeweiligen if-Anweisung \\

\textbf{i) Anweisung A:} \\
\begin{lstlisting}
int x = 5;
if (x > 1 || x < 10) {
  x += 3;
  } else {
    x -= 2;
    }
\end{lstlisting}

$\rightarrow x=8$ \\

\textbf{ii) Anweisung B:} \\
\begin{lstlisting}
int x = 1;
if (x>=1) {
  if (x<=1) {
    x = 7;
  }
}    
\end{lstlisting}

$\rightarrow x=7$ \\

\textbf{ii) Anweisung C:} \\
\begin{lstlisting}
int x = 10;
if (x>10) {
  if (x<10) {
    x = 1;
  }
} else {    
  x = -1;
  }
\end{lstlisting}

$\rightarrow x=-1$ \\

c) Welche Werte nimmt die Variable sum an, angefangen mit der Initialisierung über die Schleifeniterationen bis zum Ende der Ausführung der jeweiligen Schleife? \\

\textbf{i) Schleife A:} \\
\begin{lstlisting}
int index = 8;
int sum = 0; 
while(index >= 4) {
  index -= 2; 
  sum += index; 
  }
\end{lstlisting}

  \begin{tabular}{|c|c|c|c|c|}
  \hline
index & 8 & 6 & 4 & 2 \\
  \hline
sum & 0 & 6 & 10 & 12 \\
  \hline
  \end{tabular}
  \\

\textbf{ii) Schleife B:} \\
\begin{lstlisting}
int value = 6;
int sum = 0; 
do {
  sum += value; 
  value += 3; 
} 
while (value < 8);
\end{lstlisting}

  \begin{tabular}{|c|c|c|}
  \hline
value & 6 & 9  \\
  \hline
sum & 0 & 6  \\
  \hline
  \end{tabular}
\\

\textbf{iii) Schleife C:} \\
\begin{lstlisting}
int value = 6;
int sum = 0; 
for (\textbf{int} index = 0;$ index < 8$; index++) {
  sum += value; 
  value += 3;
  index += 2;
  }
\end{lstlisting}

\begin{flushleft}
 \begin{tabular}{|c|c|c|c|c|}
  \hline
index & 0 & 3 &  6 & 9\\
  \hline
value & 6 & 9 & 12 & 15 \\
  \hline
sum & 0 & 6 & 15 & 27\\
  \hline
  \end{tabular}
\end{flushleft}


%----------------------------------------------------------------------------------------

\newpage

\section{Blatt 04}

\paragraph{Aufgabe 4.3} Compiler-Fehler und Laufzeitfehler \\

a) Fragment 1 \\

\begin{lstlisting}
int[] a = new int[127]; 

for (int i = 0; i $\leq 127;$ i++ ) {
  a[i] = i; 
} 
\end{lstlisting}

Laufzeitfehler \\
Zeile 2 ($\textbf{for} ( \textbf{int} i = 0; i \leq 127; i++ $) \{) liefert das Problem. \\
Startbedingung der for-Schleife ist i $\leq 127$, da aber das Array die Länge 127 hat, also das letzte Element des Arrays den Index 126 hat, kann die Schleife nicht laufen, weil sie erst ab Index 127 oder größer starten kann. \\

b) Fragment 2 \\

\begin{lstlisting}
int number = 303; 
int[] b = \textbf{new} int[number]; 

while (number $>$ 0) {
  b[number$--$] = number + 7; 
} 
b[number] = -12;
\end{lstlisting}

Laufzeitfehler \\
Zeile 3 und 4 (\textbf{while} (number $>$ 0) \{ und b[number$--$] = number + 7;) liefert das Problem. \\
Es entsteht eine Endlosschleife in der while-Schleife, da number immer größer ist als 0, ist die Bedingung für die while-Schleife immer true, sodass sie ewig läuft.

c) Fragment 3 \\

\begin{lstlisting}
int[] c; 
c = new int[12]; 

for ( $\textbf{int} i = c.length-1; i \geq 0; i-- $) {
  c[i] = "Hello World"; 
}
\end{lstlisting}

Compiler-Fehler \\
Zeile 4 (c[i] = "Hello World";) liefert das Problem. \\
Java liefert: "Type mismatch: cannot convert from String to int" \\
Der Datentyp des Arrays ist int, d.h. er kann seinen Datentyp nicht plötzlich auf String ändern. Daher kommt ein Compiler-Fehler, wenn man versucht einen String einem Index zu zuordnen.

d) Fragment 4 \\

\begin{lstlisting}
int num_fractions = 0; 
float[] fractions = new float[num_fractions]; 

for(int i = 0; i < fractions.length; i++ ) {
  fractions[i] = 0.1 * i / fractions.length; 
}
\end{lstlisting}

Compiler-Fehler \\
Zeile 4 (fractions[i] = 0.1 * i / fractions.length;) liefert das Problem. \\
Java liefert: "Type mismatch: cannot convert from double to float" \\
Der Datentyp des Arrays ist float. Da man aber in der Schleifenanweisung als Ergebnis, den Wert als double bekommt,also ein double einem Index vom Array float zuordnen will, gibt es ein Compiler-Fehlermeldung. \\

e) Fragment 5 \\

\begin{lstlisting}
char[] zeichen = new char[100]; 
int[] zahlen = new int[200]; 
for (int i = 0; i < zahlen.length; i++ ) { 
  zeichen[i] = 'a'; 
  zahlen[i] = 1;
}
\end{lstlisting}

Laufzeitfehler \\
Zeile 3 (\textbf{for} ( \textbf{int} i = 0; i < zahlen.length; i++ ) \{) liefert das Problem. \\
Die for-Schleife weist in ihren Anweisungen beide Arrays-Indizes Werten zu, da die Arrays aber nicht dieselbe Länge haben, gibt es Problem bei der Wertezuweisung ab Index 100 und es kommt zum Fehler. \\

f) Fragment 6 \\

\begin{lstlisting}
boolean[] true; 
true[] = new boolean[2]; 
true[0] = false; 
true[1] = true; 
\end{lstlisting}

Compiler-Fehler\\
Alle Zeilen liefern den Fehler. \\
Nach boolean[] folgt der Variablenname des Arrays. Da der Bezeichner true ein reserviertes Wort ist, kann man diesen nicht als Variablennamen verwenden. 
In den folgenden Zeilen ist es ein Folgefehler das true als Variablenname verwendet wurde. \\
Außerdem wurde in Zeile 2 das Array falsch erzeugt. Angenommen der Variablenname t wurde für das Ergebnis angegeben. So wäre die korrekte 2. Zeile entweder: \\
1. t = \textbf{new} boolean[2]; \\
2. \textbf{boolean[]} t = \textbf{new} boolean[2];\\
Nach dem Variablennamen kommen keine eckigen Klammern! \\

\subparagraph{g)} Fragment 7

\begin{lstlisting}
double Lichtg = 299792458.0; \\
double Lichtg2 = Lichtg * Lichtg; \\
double[] energy; \\

for ( int i = 1; i <= 10; i++ $) { 
  double en = (double) i * Lichtg2; 
  energy = new double[10]; 
  energy[i-1] = en; 
} 
System.out.println(energy[2]);
\end{lstlisting}

Compiler-Fehler \\
fehlende Zeile zwischen 3 und 4\\
Java liefert: "The local variable energy may not have been initialized" \\
Die Erzeugung des Arrays (bsp. energy = new double[100];) fehlt nach der Deklaration in der 3. Zeile. Da die for-Schleife aber auf das Array zugreifen will, aber zurzeit kein Array "existiert", entsteht eine Compiler Fehler an der Stelle. \\

h) Fragment 8 \\

\begin{lstlisting}
int[] a = new int[10]; 
int[] b = new int[10]; 
int k = 0; 
for ($ k = 0; k \< 10; k++ $) 
  a[k] = k; 
b[k] = k; 
if ( b[5] $<$ 10 ) { 
  a[5] = b[6]; 
}
\end{lstlisting}

Laufzeitfehler \\
Zeile 6 (b[k] = k;) liefert das Problem.\\
Es fehlt eine Klammer um Zeile 5 und 6, sodass man die Anwendungen der for-Schleife zuordnen kann. Ohne Klammer wird nur Zeile 5 also "a[k] = k;" der for-Schleife zugeordnet und es entsteht nur ein Wert im Array bei b[0]=0, d.h. die if-Abfrage kann gar nicht laufen, da keine Werte für den Index 5 und 6 im Array b existieren. \\

%----------------------------------------------------------------------------------------

\newpage

\section{Blatt 05}

\paragraph{Aufgabe 5.2} Realweltobjekte \\
Objekte repräsentieren Dinge aus der realen Welt. \\
Sie besitzen Eigenschaften (Attribute) und Funktionen (Methoden)\\

\begin{tabular}{|c|c|c|}
 \hline
 & Attribute & Methoden \\
 \hline
 Einkaufszettel & vat: double & calculatePrice(): double\\
                & items[]: String & calculateVat(): double \\
                & price: double & countItems(): integer \\
 \hline 
 Getränk & color: String & calculateVolume(): double \\
         & calories: double & tasteGood(): boolean \\
         & amountSugar: double & freezingPoint(): double \\
 \hline
\end{tabular}
\\

%--------------------------------------------------

\paragraph{Aufgabe 5.3} Verschiedene, klausurähnliche Aufgaben \\

a) Boolesche Ausdrücke und Präzedenzregeln. \\

\begin{center}
$x = 1.0f > 1.1f == -3 * +9 +1/2 <-20 \:$ != true
\end{center}

$x = 1.0f > 1.1f == -3 * +9 +1/2 <-20 \:$ != true \\
$\rightarrow$ $x = 1.0f > 1.1f == (-3) * (+9) (+1/2) <-20 \:$ != true \\
$\rightarrow$ $x = 1.0f > 1.1f == -27 + 0.5 <-20 \:$ != true \\
$\rightarrow$ $x = 1.0f > 1.1f == -26.5 <-20 \:$ != true \\
$\rightarrow$ $x = false == true \:$ != true \\
$\rightarrow$ $x = false $ != true \\
$\rightarrow$ x = true \\

Welchen Wert hat x? \\
x = true \\

b) \\

\begin{flushleft}
i) Was bewirken die Anweisungen? \\
\fbox{
\begin{tabular}{c}
TurnierSpieler maier; \\
maier = new TurnierSpieler();
\end{tabular}
} \\
1) Variable vom Typ Turnierspieler deklarieren ohne einen Wert \\
2) der Variablen maier wird eine neue Instanz der Klasse TurnierSpieler ohne Parameter zugeordnet 
\end{flushleft}

\begin{flushleft}
ii) Schreiben Sie eine Codezeile, welche dem Spieler einen Namen zuweist.
\fbox{
\begin{tabular}{c}
maier.name = "Maier";
\end{tabular}
} \\
\end{flushleft}

c) \\

\begin{flushleft}
i) Modifier für Attribute, bei einer strikten Kapselung \\
$\rightarrow$ \textbf{private}
\end{flushleft}

\begin{flushleft}
ii) Schleifenbedingung \fbox{
\begin{tabular}{c}
while (this != null) $\lbrace$ 
 dosomething;$\rbrace$
\end{tabular}
}, die in einer nicht-statischen Methode auftaucht, vereinfacht äquivalent darstellen \\
$\rightarrow$  \fbox{
\begin{tabular}{c}
\textbf{while (true) $\lbrace$ 
 dosomething;$\rbrace$}
\end{tabular}
} \\
\end{flushleft}

\begin{flushleft}
iii) Unterschied zwischen einer statischen und nicht-statischen Methode \\
$\rightarrow$ \textbf{statische Methoden sind von "überall" aus sichtbar} \\
\textbf{nicht-statische Methoden sind nur innerhalb der Instanz sichtbar}
\end{flushleft}

d) Geben Sie an, welche Ausgabe das folgenden Programm erzeugt \\

\begin{flushleft}
\fbox{
\begin{tabular}{c}
1.0  \\
-1.0  \\
-1.0  \\
1.0  \\
-1.0  \\
1.0 (10.0) \\
\end{tabular}
} \\
\end{flushleft}

\subparagraph{e)}
Gegeben seien die Zahlen byte a = 31 und byte b = 15.

\begin{flushleft}
i) Wie werden a,b intern im Rechne dargestellt? \\
$\rightarrow$ \textbf{a = 0001 1111}\\
\textbf{b = 0000 1111}
\end{flushleft}

\begin{flushleft}
ii) Führen Sie mit der internen Darstellung die Rechnung c= a-b druch. \\
Gebe die Zwischenschritte an\\
\end{flushleft}

\begin{flushleft}
Zweierkomplement: b = 1111 0001 \\
\begin{tabular}{cr}
	&$ 0001 1111 $	\\
   +&$ 1111 0001$	\\\hline 
   &$  0001 0000$
\end{tabular}\\

\begin{flushleft}
  \begin{tabular}{|c|c|}
  \hline
Addition & Übertrag\\
  \hline
1+1=0 & 1 \\
  \hline
1+0+1=0 & 1 \\
  \hline
1+0+1=0 & 1 \\
  \hline
1+0+1=0 & 1 \\
  \hline
1+1+1=1 & 1 \\
  \hline
0+1+1=0 & 1 \\
  \hline
0+1+1=0 & 1 \\
  \hline
0+1+1=0 & 1 \\
  \hline
  \end{tabular} \\

%---------------------------------------------------------------------------------------
\newpage

\section{Blatt 06}

%---------------------------------------------------------------------------------------
\newpage

\section{Blatt 07}

%---------------------------------------------------------------------------------------
\newpage

\section{Blatt 08}

%---------------------------------------------------------------------------------------
\newpage

\section{Blatt 09}

%---------------------------------------------------------------------------------------
\newpage

\section{Blatt 010}

%---------------------------------------------------------------------------------------
\newpage

\section{Blatt 11}

%---------------------------------------------------------------------------------------

\end{document}